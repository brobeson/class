# Counting Cars in UAV Imagery

## Running the demonstration scripts

Two demonstration scripts are provided: *uav_short_demo.m* and *uav_full_demo.m*. Simply run the script as you would any Matlab script:

```matlab
>> uav_full_demo
```

The short demonstration runs in a minute or two. It will generate figures showing the results of each major step in the process, and will present a table of car count data, and a table of execution time data. The tables are also saved to the workspace directory as CSV files: *short_demo_counts.txt* and *short_demo_times.txt*.

The full demonstration takes about five hours to run. It does not generate intermediate figures, but presents the same tables upon completion. The tables are saved as *full_demo_counts.txt* and *full_demo_times.txt*.

### Prerequisites

Both scripts require the trained support vector machines available in the workspace directory. The SVMs are the files *uav_asphalt_svm.mat* and *uav_keypoitn_svm.mat*.

The demo scripts require the appropriate true count CSV file to be available in the workspace directory. The CSV files are *true_counts_small.txt* and *true_counts_full.txt*.

The demo scripts also require image files for processing. The short demo requires *small_img.png* and *small_img2.png*. The full demo requires *IMG_0085.JPG*, *IMG_0105.JPG*, and *IMG_0107.JPG*.

This table summarizes the required files:

| File | Short demo | Full demo |
|:-----|:----------:|:---------:|
| uav\_asphalt\_svm.mat   | :white\_check\_mark: | :white\_check\_mark: |
| uav\_keypoinit\_svm.mat | :white\_check\_mark: | :white\_check\_mark: |
| true\_counts\_small.txt | :white\_check\_mark: |                    |
| true\_counts\_full.txt  |                    | :white\_check\_mark: |
| small\_img.png         | :white\_check\_mark: |                    |
| small\_img2.png        | :white\_check\_mark: |                    |
| IMG\_0085.JPG          |                    | :white\_check\_mark: |
| IMG\_0105.JPG          |                    | :white\_check\_mark: |
| IMG\_0107.JPG          |                    | :white\_check\_mark: |

## Using the car counting function

The entry point for the car counting is `uav_car_counter()`. The function requires a list of image file names for analysis, and a list of file names identifying the SVMs. *Note that this function does not produce the tables generated by the demonstration scripts.* Use `help uav_car_counter` for full function help.

## Run time

Run time of the process depends on the size of the image. Test runs on an Intel Core i7 with eight cores and 16 GB of RAM yielded the following results:

| Image size (pixels) | Run time |
|:--------------------|---------:|
| 1280 x 1024         | 00:00:30 |
| 5472 x 3648         | 01:45:00 |

## Main processing steps

### Asphalt segmentation

Asphalt segmentation is done by the function `asphalt = uav\_find\_asphalt(img, svm, erode\_se\_radius, dilate\_se\_radius)`.

| Parameter | Description |
|:----------|:------------|
| img       | The image being processed. A uint8 RGB image. |
| svm       | The `ClassificationSVM` trained for asphalt segmentation. |
| erode\_se\_radius | The radius of a disk structuring element to use for eroding noise in the initial mask. This should be a value derived from the image resolution, eg: 30 cm / 4 cm/pixel. |
| dilate\_se\_radius | The radius of a disk structuring element to use for dilating the mask. This should be a value derived from the image resolution, eg: 300 cm / 4 cm/pixel. This is typically much larger than the erosion radius. |
| | |
| asphalt | The resulting image mask. A binary image with 1 representing asphalt. |

This function uses the SVM to generate an initial asphalt mask. Image erosion is used to eliminate noise generated by the SVM. It then dilates by a much larger amount. The authors of the paper claim a rough estimate of the roadways is all that is required, not an exact mask.

Interestingly, the asphalt SVM is returning asphalt and background areas classified opposite the training. That is, asphalt is given class -1 and background is given class 1. `uav_find_asphalt` converts all values of -1 to 0, then subtracts the mask from 1, giving the correct mask.

Correctness can be evaluated by observing the intermediate figure. It generates three plots: the mask, the masked image (showing asphalt regions), and the image covered by the inverse mask (showing non-asphalt regions). Run time is reported by the function `uav_car_counter()`.

This step is subject to the quality of the SVM training. A poorly trained SVM will generate a poor mask. It can also require multiple runs to establish suitable values for `erode_se_radius` and `dilate_se_radius`.

This function uses `predict()` from the Statistics and Machine Learning Toolbox. Also used are `imdilate()` and `imerode()`, both from the Image Processing toolbox. These are standard toolboxes available from MathWorks.

### Key point extraction

Key point extraction is done by the function `[frames, descriptors] = uav_sift(img)`.

| Parameter | Description |
|:----------|:------------|
| img         | The image being processed. A uint8 RGB image. |
| | |
| frames      | The SIFT frames [1]. This is a matrix of class double, with four rows, and one column for each frame. The rows in order are: X, Y, S, θ. |
| descriptors | The SIFT frame descriptors [1]. These are enhanced with color information as described in [2]. The descriptors are a matrix of class double, with 152 rows, and one column for each frame. Each descriptor contains standard SIFT information, and the additional color information as described in [2].

This function uses the SIFT algorith to extract key points from the input image. The key points' geometric information is returned in the `frames` output. The `descriptors` output contains the standard SIFT descriptor, appended with color information at the key points' locations in the image. This is the RGB and HSV data for the pixel. It also contains the RGB information for three image dilations and three image erosions.

Correctness can be evaluated by observing the intermediate figure. It shows the image with the key points overlaid as red dots. Run time is reported by the function `uav_car_counter()`.

SIFT is subject to tuning of some input parameters. Getting these parameters correct can require multiple runs of this function. Tuning the peak threshold parameter, as described in the paper, results in no key points being extracted. I suspect that not being able to set this parameter results in too many key points being extracted.

This function uses `vl_sift()` from the VLFeat toolbox. This toolbox can be downloaded from http://www.vlfeat.org/download.html. Installation instructions are available at http://www.vlfeat.org/install-matlab.html. Also used are `imdilate()` and `imerode()`, both from the Image Processing toolbox. This is a standard toolbox available from MathWorks.

### Key point classification

Key point classification is not given a separate function. It just uses a single Matlab function, then a straightfoward loop. It requires the key point frames and descriptors from the key point extraction step, and the trained key point classification SVM. Using the descriptors as the observations, `predict()` is used to classify them. For any key point classified as -1 (non-car), the corresponding key point frame is deleted. The descriptors are not used after this, so they are not purged as the frames are. This step results in a reduced set of key point frames.

Correctness can be evaluated by observing the intermediate figure. It shows the image with the car key points overlaid as red dots. Run time is reported by the function `uav_car_counter()`.

Like the asphalt segmentation step, this step is subject to the quality of the SVM training. An improperly trained SVM can result to too many, or too few, car key points.

This function uses `predict()` from the Statistics and Machine Learning Toolbox. This is a standard toolbox available from MathWorks.

### Key point reduction

Key point reduction involves removing car key points which are not within asphalt segments. This requires the asphalt mask from the first step, and the car key points from the previous step. For each car key point, if the point's location in the asphalt mask is 1, the point is kept; otherwise the point is rejected. The result is a further reduced set of key point frames.

Correctness can be evaluated by observing the intermediate figure. It shows the image with the car key points in asphalt overlaid as red dots. Run time is reported by the function `uav_car_counter()`.

The quality of the output is subject the quality of the asphalt mask. Any errors in generating the mask propogate to generating erroneous key point data.

This step only uses basic Matlab functionality. No external toolboxes are required.

### Key point merging

The final step is merging of key point frames, implemented in the function `[merged_keypoints, n] = uav_merge_keypoints(key_points, t_distance)`.

| Parameter | Description |
|:----------|:------------|
| key\_points       |  The set of car key points to merge. This should be a 2D matrix. Each column is a key point. Each key point consists of four rows: X, Y, S, and θ. |
| t\_distance       |  The threshold distance for merging key points. Points closer than this distance are merged. This value should be expressed in pixel units, and take into consideration the image resolution. |
| merged\_keypoints |  The set of key points remaining after the merge operation. |
| n                 | The number of key points after the merging operation is complete. |

Merging the set of key points follows this algorithm:

- Append a value _m = 1_ to each key point frame.
- Create an NxN matrix _D_, where _N_ is the number of key points.
  - Set each matrix element _ij_, for _i =/= j_, to the distance between key
     points _i_ and _j_.
  - Set the diagonal _i == j_ to the maximum system value (`realmax`).
- Set _tmin_ to the minimum value of _D_.
- While _t\distance < tmin_
  - Determine the key points _i_ and _j_ corresponding to _tmin_.
  - Merge key points _i_ and _j_ to get key point _k_.
  - Remove key points _i_ and _j_ from the set of key point frames.
  - Add key point _k_ to the set of key point frames.
  - Remove rows and columns _i_ and _j_ from _D_.
  - Append a row and column to _D_.
  - Calculate the distance between each key point and the new key point _k_. Set
    the corresponding elements of _D_ to the distances. Set the distatnce from
    _k_ to itself to `realmax`.
  - Set _tmin_ to the minimum value of _D_.
  - Repeat the loop
- Delete all key points with _m == 1_.
- Set _n_ to the number of remaining key points.

Two key points are merged via a weighted average:

```
        (i\_x)(i\_m) + (j\_x)(j\_m)
k\_x = ----------------------------
                i\_m + j\_m
        (i\_y)(i\_m) + (j\_y)(j\_m)
k\_y = ----------------------------
                i\_m + j\_m
        (i\_s)(i\_m) + (j\_s)(j\_m)
k\_s = ----------------------------
                i\_m + j\_m
        (i\_θ)(i\_m) + (j\_θ)(j\_m)
k\_θ = ----------------------------
                i\_m + j\_m
k\_m = i\_m + j\_m + 1
```

Correctness can be evaluated by observing the intermediate figure. It shows the image with the merged key points overlaid as red dots. Run time is reported by the function `uav_car_counter()`.

This function is subject to a single threshold distance. This doesn't consider that vehicles are rectangular, or that they can differ significantly in size (consider a sports car compared to a semi-truck).

This function only uses basic Matlab functionality. No external toolboxes are required.







## Training the support vector machines (SVM)

Two SVMs are required to process imagery: asphalt segmentation, and key point
classification. You can train your own SVMs, or use the two provided SVMs:
*uav\_asphalt\_svm.mat* and *uav\_keypoint\_svm.mat*. To train your own SVMs,
follow these steps:

### Training the asphalt segmentation SVM
1. Observations are the red, green, and blue pixel values.
1. Asphalt observations must be assigned to class 1.
1. Non-asphalt observations must be assigned to class -1.
1. Use this line to train the SVM: `svm = fitcsvm(double(observations), asphalt_classes);`
  1. The returned SVM must be a `ClassificationSVM`.
  1. The returned SVM must be stored in a variable named 'svm'.
1. Save the SVM to a .mat file: `save(filename, 'svm');`.

### Training the key point classification SVM
1. Observations are SIFT key point descriptors.
1. Use this line to get the descriptors: `[frames, descriptors] = uav_sift(training_img);`.
1. Car key points must be assigned to class 1.
1. Non-car key points must be assigned to class -1.

### Prerequisites

###### Matlab R2016b

The code was developed using Matlab R2016b, but it should be able to run on
earlier versions.

The VLFeat toolbox must be installed. It can be downloaded from http://www.vlfeat.org/download.html. Installation instructions are available at http://www.vlfeat.org/install-matlab.html.

###### Imagery

To run the demonstration scripts, the sample imagery must be in your workspace
directory:

- uav\_short\_demo.m
  - small\_img.png
  - small\_img2.png
- uav\_full\_demo.m
  - IMG\_0085.JPG
  - IMG\_0105.JPG
  - IMG\_0107.JPG
